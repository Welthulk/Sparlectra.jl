# Copyright 2023–2026 Udo Schmitz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Author: Udo Schmitz (https://github.com/Welthulk)
# Date: 20.6.2023
# include-file exportMatPower.jl
# further details see: https://github.com/Welthulk/CIMDraw/blob/master/js/matpower.js

const comment = "% This file was generated by Sparlectra\n"

function writeHeader(sb_mva::Float64, file, case::AbstractString)
  write(file, comment)
  write(file, "function mpc = $case\n")
  write(file, "%% MATPOWER Case Format : Version 2\n")
  write(file, "mpc.version = '2';\n")
  write(file, "%%-----  Power Flow Data  -----%%\n")
  write(file, "%% system MVA base\n")
  write(file, "mpc.baseMVA = $sb_mva;\n")
end # writeHeader

function writeBusData(NodeVec::Vector{Node}, file)
  write(file, "%% bus data\n")
  write(file, "mpc.bus = [\n")
  write(file, "%bus\ttype\tPd\tQd\tGs\tBs\tarea\tVm\tVa\tbaseKV\tzone\tVmax\tVmin\n")

  rows = 0
  hasPVBus = false
  slackIdx = 0
  vgSlack = 1.0
  for node in NodeVec
    rows += 1
    bus_i = node.busIdx
    Name = node.comp.cName
    ID = node.comp.cID

    val = Int(node._nodeType)
    if val <= 0 || val > 4
      @warn "Node $(ID) Node-Type $(val) not supported yet! -> set to 1 (PQ)"
      num = 1
    elseif val == 1
      num = 1
    elseif val == 2
      num = 2
      hasPVBus = true
    elseif val == 3
      num = 3
      Name = Name * " (slack)"
      slackIdx = bus_i
      vgSlack = node._vm_pu
    elseif val == 4
      num = 4
      Name = Name * " (isolated)"
    end

    pSum = (node._pƩLoad === nothing) ? 0.0 : node._pƩLoad
    qSum = (node._qƩLoad === nothing) ? 0.0 : node._qƩLoad

    GS = (node._pShunt === nothing) ? 0.0 : node._pShunt
    BS = (node._qShunt === nothing) ? 0.0 : node._qShunt

    area = (node._area === nothing) ? 1 : node._area #https://zepben.github.io/evolve/docs/cim/cim100/TC57CIM/IEC61970/Base/ControlArea/ControlArea/      

    vm_pu = (node._vm_pu === nothing) ? 1.0 : node._vm_pu
    vm_pu = round(vm_pu, digits = 2)
    va_deg = (node._va_deg === nothing) ? 0.0 : node._va_deg
    va_deg = round(va_deg, digits = 2)
    if isnothing(node.comp.cVN)
      @warn "Base Voltage not defined for node $(node.comp.cID) -> set to 1.0"
      baseKV = 1.0
    else
      baseKV = node.comp.cVN
    end

    lZone = (node._lZone === nothing) ? 1 : node._lZone

    Vmax = 1.1
    Vmin = 0.9
    #! format: off
    line = string(bus_i, "\t", num, "\t", pSum, "\t", qSum, "\t", GS, "\t", BS, "\t", area, "\t", vm_pu, "\t", va_deg, "\t", baseKV, "\t", lZone, "\t", Vmax, "\t", Vmin, "; %Bus: " * Name * " (ID: " * ID * ")\n")
    #! format: on
    write(file, line)
  end
  write(file, "];\n")
  return hasPVBus, slackIdx, vgSlack
end # writeBusData

function writeGeneratorData(sb_mva::Float64, NodeDict::Dict{Int,Node}, ProSumVec::Vector{ProSumer}, file, hasPVBus::Bool, slackIdx::Int, vgSlack::Float64)
  #! format: off
  write(file, "%% generator data\n")
  write(file, "mpc.gen = [\n")
  write(file, "%bus\tPg\tQg\tQmax\tQmin\tVg\tmBase\tstatus\tPmax\tPmin\tPc1\tPc2\tQc1min\tQc1max\tQc2min\tQc2max\tramp_agc\tramp_10\tramp_30\tramp_q\tapf\n")
  #! format: on
  slackGeneratorFound = false

  function getLine(node::Node, prosum::ProSumer)
    name = prosum.comp.cName
    cTypStr = string(prosum.comp.cTyp)
    pc1 = pc2 = qc1min = qc1max = qc2min = qc2max = ramp_agc = ramp_10 = ramp_30 = ramp_q = apf = 0.0

    bus_i = node.busIdx

    Vg = (node._vm_pu === nothing) ? 1.0 : node._vm_pu
    Vg = round(Vg, digits = 2)

    p = (prosum.pVal === nothing) ? 0 : prosum.pVal
    q = (prosum.qVal === nothing) ? 0 : prosum.qVal

    qmax = (prosum.maxQ === nothing) ? sb_mva : prosum.maxQ
    qmin = (prosum.minQ === nothing) ? -1.0 * sb_mva : prosum.minQ
    mbase = (prosum.ratedS === nothing) ? sb_mva : prosum.ratedS
    status = 1
    pmax = (prosum.maxP === nothing) ? sb_mva : prosum.maxP
    pmin = (prosum.minP === nothing) ? -1.0 * sb_mva : prosum.minP
    #! format: off
    line = string( bus_i, "\t", p, "\t", q, "\t", qmax,"\t", qmin, "\t", Vg, "\t",  mbase, "\t", status, "\t",  pmax, "\t", pmin, "\t",  pc1, "\t", pc2, 
                          "\t", qc1min, "\t", qc1max, "\t", qc2min, "\t", qc2max,  "\t",   ramp_agc, "\t", ramp_10,"\t",  ramp_30, "\t",  ramp_q, "\t",  apf, "; %Gen: ",  cTypStr, "_",  name, ")\n", )
    #! format: on
    return true, line
  end

  function getLineSlackGenerator()
    p = q = 0.0
    qmax = sb_mva
    qmin = -1.0 * sb_mva
    mbase = sb_mva
    status = 1
    pmax = sb_mva
    pmin = -1.0 * sb_mva
    pc1 = pc2 = qc1min = qc1max = qc2min = qc2max = ramp_agc = ramp_10 = ramp_30 = ramp_q = apf = 0.0
    #! format: off
    line = string(slackIdx, "\t",  p,"\t", q,"\t", qmax,"\t", qmin,"\t", vgSlack,"\t", mbase,"\t", status, "\t", pmax, "\t",  pmin, "\t", pc1, "\t", pc2, "\t", qc1min, "\t", qc1max, "\t",  qc2min, "\t", qc2max, 
                            "\t", ramp_agc,"\t",  ramp_10, "\t", ramp_30, "\t", ramp_q, "\t", apf,"; %Gen: Slack-Generator (ID: ", slackIdx, ")\n", )
    #! format: on
    return line
  end

  for prosum in ProSumVec
    if isGenerator(prosum.proSumptionType)
      bus_i = prosum.comp.cFrom_bus

      if haskey(NodeDict, bus_i)
        node = NodeDict[bus_i]
      else
        @warn "Node $(bus_i) not found"
        continue
      end

      if node.busIdx == 0
        @warn "Node $nodeID has no kidx: $(node.busIdx), $(node)"
        continue
      end

      if bus_i == slackIdx
        slackGeneratorFound = true
      end
      result, line = getLine(node, prosum)
      if result
        write(file, line)
      end
    end # if   
  end # for
  if !hasPVBus && !slackGeneratorFound
    @info "No PV-Bus found and no Slack-Generator defined -> add a Slack-Generator"
    line = getLineSlackGenerator()
    write(file, line)
  end # if
  write(file, "];\n")
end # WriteGeneratorData

function writeBranchData(sb_mva::Float64, branchVec::Vector{Branch}, file)
  #! format: off
  write(file, "%% branch data\n")
  write(file, "mpc.branch = [\n")
  write(file, "%fbus\ttbus\tr\tx\tb\trateA\trateB\trateC\tratio\tangle\tstatus\tangmin\tangmax\n")
  #! format: on
  for br in branchVec
    fbus = br.fromBus
    tbus = br.toBus
    r = round(br.r_pu, digits = 8)
    x = round(br.x_pu, digits = 8)
    b = round(br.b_pu, digits = 8)
    g = round(br.g_pu, digits = 8)
    if abs(g) > 1e-6
      @info "Conductance g not zero and negleted in matpower export, g=", g
    end
    rateA = 0 # 0 for unlimited
    if !isnothing(br.sn_MVA)
      rateA = br.sn_MVA
    end
    rateB = 0 # 0 for unlimited
    rateC = 0 # 0 for unlimited

    ratio = br.ratio
    angle = br.angle
    status = Int(br.status)
    angmin = -360 #br.angmin
    angmax = 360 #br.angmax

    type = br.comp.cName

    if br.status == 0 # out of service
      type = "(no service) " * type
    end

    cID = br.comp.cID
    #! format: off
    line = string(fbus, "\t", tbus, "\t", r, "\t", x, "\t", b, "\t", rateA, "\t", rateB, "\t", rateC, "\t", ratio, "\t", angle, "\t", status, "\t", angmin, "\t", angmax, "; %Branch: " * type * " (ID: " * cID * ")\n")
    #! format: on
    write(file, line)
  end # for

  write(file, "];\n")
end # writeBranchData

"""
    writeMatpowerCasefile(net::Net, pathfilename::String)

Write Matpower case files.

# Arguments
- `net::Net`: Network object.
- `pathfilename::String`: Path and filename to write the Matpower case file.

# Example
```julia
net = Net(...)
writeMatpowerCasefile(net, "casefile.m")
```
"""
function writeMatpowerCasefile(net::Net, pathfilename::String)
  base, ext = splitext(pathfilename)

  case = basename(base)
  base = base * ".m"
  @info "convertion to Matpower CASE-Files, Testcase: ($case)"
  NodeDict = Dict{Int,Node}()
  for n in net.nodeVec
    NodeDict[n.busIdx] = n
  end

  file = open(pathfilename, "w")
  writeHeader(net.baseMVA, file, case)
  hasPVBus, slackIdx, vgSlack = writeBusData(net.nodeVec, file)

  writeGeneratorData(net.baseMVA, NodeDict, net.prosumpsVec, file, hasPVBus, slackIdx, vgSlack)

  writeBranchData(net.baseMVA, net.branchVec, file)
  #writeCostData(file)
  close(file)
end # writeMatpowerCasefile
